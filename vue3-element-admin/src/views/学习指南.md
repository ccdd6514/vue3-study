# toRef 与 toRefs 完整学习指南

## 一、toRef 详解

### 1.1 基本概念

```typescript
import { reactive, toRef } from "vue";

const state = reactive({
  count: 0,
  message: "Hello",
});

// toRef: 为单个属性创建 ref
const countRef = toRef(state, "count");

console.log(countRef.value); // 0
countRef.value++; // 修改 ref
console.log(state.count); // 1 - 源对象也更新了！
```

**核心特点：**

- 创建的 ref 与源对象**双向绑定**
- 修改 ref 会影响源对象
- 修改源对象会影响 ref

### 1.2 类型签名

```typescript
function toRef<T extends object, K extends keyof T>(
  object: T,
  key: K
): ToRef<T[K]>;

// 示例
const state = reactive({
  name: "Alice",
  age: 30,
});

const nameRef = toRef(state, "name");
// nameRef: Ref<string>

const ageRef = toRef(state, "age");
// ageRef: Ref<number>

// ❌ 类型错误
const invalidRef = toRef(state, "invalid");
// Error: Argument of type '"invalid"' is not assignable to parameter of type '"name" | "age"'
```

### 1.3 使用场景

#### 场景 1: 传递单个响应式属性给子组件

```vue
<!-- 父组件 -->
<script setup lang="ts">
import { reactive, toRef } from "vue";
import Counter from "./Counter.vue";

const state = reactive({
  count: 0,
  message: "Hello",
  user: { name: "Alice" },
});

// ✅ 使用 toRef - 保持响应性
const countRef = toRef(state, "count");
</script>

<template>
  <!-- 传递单个属性，保持响应式连接 -->
  <Counter :count="countRef" />
  <p>Parent count: {{ state.count }}</p>
</template>

<!-- 子组件 Counter.vue -->
<script setup lang="ts">
import { type Ref } from "vue";

defineProps<{
  count: Ref<number>;
}>();
</script>

<template>
  <div>
    <p>Count: {{ count }}</p>
    <button @click="count++">Increment</button>
  </div>
</template>
```

**对比：不使用 toRef**

```vue
<!-- ❌ 错误方式 -->
<script setup lang="ts">
const state = reactive({
  count: 0,
});

// 直接传递值，失去响应性
</script>

<template>
  <Counter :count="state.count" />
  <!-- 子组件修改 count 不会影响父组件 -->
</template>
```

#### 场景 2: 组合式函数中选择性暴露属性

```typescript
import { reactive, toRef, computed } from "vue";

function useUser() {
  const state = reactive({
    firstName: "John",
    lastName: "Doe",
    age: 30,
    email: "john@example.com",
    password: "secret123", // 敏感信息
  });

  // ✅ 只暴露需要的属性
  return {
    firstName: toRef(state, "firstName"),
    lastName: toRef(state, "lastName"),
    age: toRef(state, "age"),
    // 不暴露 password

    fullName: computed(() => `${state.firstName} ${state.lastName}`),
  };
}

// 使用
const user = useUser();
user.firstName.value = "Jane"; // ✅ 可以修改
// user.password // ❌ 访问不到，保护了敏感数据
```

#### 场景 3: 处理深层嵌套对象

```typescript
const state = reactive({
  user: {
    profile: {
      settings: {
        theme: "dark",
        notifications: true,
      },
    },
  },
});

// ✅ 为深层属性创建 ref
const themeRef = toRef(state.user.profile.settings, "theme");

themeRef.value = "light"; // 修改深层属性
console.log(state.user.profile.settings.theme); // 'light'
```

#### 场景 4: 可选属性的默认值

```typescript
import { toRef } from "vue";

function useConfig(options?: { timeout?: number }) {
  // ✅ toRef 可以处理 undefined，提供默认值
  const timeoutRef = toRef(options || {}, "timeout");

  // 如果 options.timeout 不存在，ref.value 是 undefined
  const timeout = timeoutRef.value ?? 3000; // 使用默认值

  return { timeout };
}

// 使用
const config1 = useConfig({ timeout: 5000 }); // 5000
const config2 = useConfig(); // 3000 (默认值)
```

---

## 二、toRefs 详解

### 2.1 基本概念

```typescript
import { reactive, toRefs } from "vue";

const state = reactive({
  count: 0,
  message: "Hello",
  active: true,
});

// toRefs: 批量转换所有属性
const refs = toRefs(state);

// refs 的类型：
// {
//   count: Ref<number>
//   message: Ref<string>
//   active: Ref<boolean>
// }

refs.count.value++; // 修改 ref
console.log(state.count); // 1 - 源对象同步更新
```

### 2.2 解决解构丢失响应性问题

```typescript
import { reactive, toRefs } from "vue";

const state = reactive({
  count: 0,
  message: "Hello",
});

// ❌ 错误：直接解构失去响应性
const { count, message } = state;
count++; // 只是修改了局部变量，不会触发更新

// ✅ 正确：使用 toRefs 后解构
const { count: countRef, message: messageRef } = toRefs(state);
countRef.value++; // 触发响应式更新
```

### 2.3 在组合式函数中的应用

#### 完整示例：useCounter

```typescript
import { reactive, toRefs, computed } from "vue";

function useCounter(initial = 0) {
  const state = reactive({
    count: initial,
    history: [] as number[],
  });

  const doubled = computed(() => state.count * 2);
  const tripled = computed(() => state.count * 3);

  function increment() {
    state.history.push(state.count);
    state.count++;
  }

  function decrement() {
    state.history.push(state.count);
    state.count--;
  }

  function reset() {
    state.history.push(state.count);
    state.count = initial;
  }

  // ✅ 使用 toRefs 解构返回
  return {
    ...toRefs(state), // count, history 都是 Ref
    doubled, // 计算属性本身就是 Ref
    tripled,
    increment,
    decrement,
    reset,
  };
}

// 组件中使用
const counter = useCounter(10);

// 所有属性都是响应式的
console.log(counter.count.value); // 10
console.log(counter.doubled.value); // 20

counter.increment();
console.log(counter.count.value); // 11
console.log(counter.history.value); // [10]
```

#### 示例：useForm

```typescript
import { reactive, toRefs, computed } from "vue";

interface FormData {
  username: string;
  email: string;
  password: string;
}

function useForm(initialData: FormData) {
  const state = reactive({
    ...initialData,
    errors: {} as Record<string, string>,
    touched: {} as Record<string, boolean>,
    isSubmitting: false,
  });

  const isValid = computed(() => Object.keys(state.errors).length === 0);

  function validate(field: keyof FormData) {
    state.touched[field] = true;

    // 简单验证逻辑
    if (!state[field]) {
      state.errors[field] = `${field} is required`;
    } else {
      delete state.errors[field];
    }
  }

  function validateAll() {
    (Object.keys(initialData) as Array<keyof FormData>).forEach(validate);
  }

  async function submit() {
    validateAll();
    if (!isValid.value) return;

    state.isSubmitting = true;
    try {
      // 模拟 API 调用
      await new Promise((resolve) => setTimeout(resolve, 1000));
      console.log("Form submitted:", {
        username: state.username,
        email: state.email,
        password: state.password,
      });
    } finally {
      state.isSubmitting = false;
    }
  }

  // ✅ 返回响应式引用
  return {
    ...toRefs(state),
    isValid,
    validate,
    validateAll,
    submit,
  };
}

// 组件中使用
const form = useForm({
  username: "",
  email: "",
  password: "",
});

// 类型安全的访问
form.username.value = "alice";
form.validate("username");
console.log(form.errors.value); // {}
console.log(form.isValid.value); // true
```

---

## 三、最佳实践

### 3.1 何时使用 toRef

```typescript
// ✅ 场景 1: 传递单个属性给子组件
const countRef = toRef(state, "count");

// ✅ 场景 2: 选择性暴露属性
function useData() {
  const state = reactive({
    /* ... */
  });
  return {
    publicProp: toRef(state, "publicProp"),
    // 不暴露 privateProp
  };
}

// ✅ 场景 3: 深层属性访问
const themeRef = toRef(state.user.settings, "theme");

// ❌ 不推荐：需要多个属性时用 toRefs
const countRef = toRef(state, "count");
const messageRef = toRef(state, "message");
const activeRef = toRef(state, "active");
// 应该用 toRefs
```

### 3.2 何时使用 toRefs

```typescript
// ✅ 场景 1: 组合式函数返回多个响应式属性
function useStore() {
  const state = reactive({
    /* ... */
  });
  return {
    ...toRefs(state), // 批量转换
    // 其他方法
  };
}

// ✅ 场景 2: 解构响应式对象
const { count, message } = toRefs(state);

// ✅ 场景 3: 传递整个对象给子组件
const stateRefs = toRefs(state);

// ❌ 不推荐：只需要一个属性时用 toRef
const refs = toRefs(state);
const countRef = refs.count; // 多此一举
// 应该直接用 toRef(state, 'count')
```

### 3.3 与 ref/reactive 的配合

```typescript
import { ref, reactive, toRefs, computed } from "vue";

// ✅ 推荐模式 1: reactive + toRefs
function useData() {
  const state = reactive({
    count: 0,
    message: "Hello",
  });

  return {
    ...toRefs(state),
    increment() {
      state.count++;
    },
  };
}

// ✅ 推荐模式 2: 混合使用
function useMixed() {
  // 简单值用 ref
  const count = ref(0);
  const message = ref("Hello");

  // 复杂对象用 reactive
  const user = reactive({
    name: "Alice",
    profile: {
      age: 30,
    },
  });

  return {
    count,
    message,
    ...toRefs(user), // 解构 user
  };
}

// ❌ 不推荐：过度使用 toRefs
function badExample() {
  const state = reactive({
    count: 0,
  });

  // 只有一个属性，直接返回 reactive 即可
  return toRefs(state); // 多余
}
```

### 3.4 性能考虑

```typescript
// ✅ 好：一次性转换
function goodPerformance() {
  const state = reactive({
    count: 0,
    message: "Hello",
    items: [] as string[],
  });

  const refs = toRefs(state); // 只调用一次

  return refs;
}

// ❌ 差：重复转换
function badPerformance() {
  const state = reactive({ count: 0 });

  setInterval(() => {
    const refs = toRefs(state); // 每次都创建新的 ref
    refs.count.value++;
  }, 1000);
}

// ✅ 好：按需转换
function selective() {
  const state = reactive({
    count: 0,
    message: "Hello",
    unused1: "data1",
    unused2: "data2",
    unused3: "data3",
  });

  // 只转换需要的属性
  return {
    count: toRef(state, "count"),
    message: toRef(state, "message"),
    // 不转换 unused*
  };
}
```

### 3.5 类型安全实践

```typescript
import { reactive, toRefs, type Ref } from "vue";

// ✅ 定义接口
interface UserState {
  name: string;
  age: number;
  email: string;
}

function useUser() {
  const state = reactive<UserState>({
    name: "Alice",
    age: 30,
    email: "alice@example.com",
  });

  // 返回类型自动推导
  return toRefs(state);
  // 返回类型：{
  //   name: Ref<string>
  //   age: Ref<number>
  //   email: Ref<string>
  // }
}

---

## 四、横向对比

| 特性 | `ref(obj.key)` | `toRef(obj, key)` | `toRefs(obj)` |
|---|---|---|---|
| 与源对象同步 | ❌ 独立快照 | ✅ 双向同步 | ✅ 双向同步 |
| 适用场景 | 独立响应式值 | 单个属性代理 | 批量属性解构 |
| 组合式函数返回 | 不适用 | 单个属性场景 | 推荐方式 ✅ |
| 模板中使用 | 自动解包 | 自动解包 | 解构后自动解包 |

---

## 五、面试必背结论

1. `toRef` / `toRefs` **不创建新的响应式数据**，只是源属性的"视图/代理"
2. 解构 `reactive` 对象前，**必须先 `toRefs`**，否则丢失响应性
3. 组合式函数（`useXxx`）返回值的标准做法：`return { ...toRefs(state), methods }`
4. `ref(obj.key)` 是**"拍快照"**，`toRef(obj, 'key')` 是**"建连接"**
```
